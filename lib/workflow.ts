import { prisma } from "./prisma";import { processUnprocessedSessions } from "./processingSchedulerNoCron";import { fileURLToPath } from "url";import { dirname, join } from "path";import { readFileSync } from "fs";const __filename = fileURLToPath(import.meta.url);const __dirname = dirname(__filename);const envPath = join(__dirname, "..", ".env.local");try {  const envFile = readFileSync(envPath, "utf8");  const envVars = envFile    .split("\n")    .filter((line) => line.trim() && !line.startsWith("#"));  envVars.forEach((line) => {    const [key, ...valueParts] = line.split("=");    if (key && valueParts.length > 0) {      const value = valueParts.join("=").trim();      if (!process.env[key.trim()]) {        process.env[key.trim()] = value;      }    }  });} catch (error) {}async function fetchTranscriptContent(  url: string,  username?: string,  password?: string): Promise<string | null> {  try {    const authHeader =      username && password        ? "Basic " + Buffer.from(`${username}:${password}`).toString("base64")        : undefined;    const response = await fetch(url, {      headers: authHeader ? { Authorization: authHeader } : {},    });    if (!response.ok) {      process.stderr.write(        `Error fetching transcript: ${response.statusText}\n`      );      return null;    }    return await response.text();  } catch (error) {    process.stderr.write(`Failed to fetch transcript: ${error}\n`);    return null;  }}export async function triggerCompleteWorkflow(): Promise<{ message: string }> {  try {    const sessionsWithoutMessages = await prisma.session.count({      where: {        messages: { none: {} },        fullTranscriptUrl: { not: null }      }    });    if (sessionsWithoutMessages > 0) {      console.log(`[Complete Workflow] Fetching transcripts for ${sessionsWithoutMessages} sessions`);      const sessionsToProcess = await prisma.session.findMany({        where: {          AND: [            { fullTranscriptUrl: { not: null } },            { messages: { none: {} } },          ],        },        include: {          company: true,        },        take: 20,      });      for (const session of sessionsToProcess) {        try {          if (!session.fullTranscriptUrl) continue;          const transcriptContent = await fetchTranscriptContent(            session.fullTranscriptUrl,            session.company.csvUsername || undefined,            session.company.csvPassword || undefined          );          if (!transcriptContent) {            console.log(`No transcript content for session ${session.id}`);            continue;          }          const lines = transcriptContent.split("\n").filter((line) => line.trim());          const messages: Array<{            sessionId: string;            role: string;            content: string;            timestamp: Date;            order: number;          }> = [];          let messageOrder = 0;          for (const line of lines) {            const timestampMatch = line.match(/^\\[([^\]]+)\\]\\s*([^:]+):\\s*(.+)$/);            if (timestampMatch) {              const [, timestamp, role, content] = timestampMatch;              const dateMatch = timestamp.match(/^(\\d{1,2})-(\\d{1,2})-(\\d{4}) (\\d{1,2}):(\\d{1,2}):(\\d{1,2})$/);              let parsedTimestamp = new Date();              if (dateMatch) {                const [, day, month, year, hour, minute, second] = dateMatch;                parsedTimestamp = new Date(                  parseInt(year),                  parseInt(month) - 1,                  parseInt(day),                  parseInt(hour),                  parseInt(minute),                  parseInt(second)                );              }              messages.push({                sessionId: session.id,                role: role.trim().toLowerCase(),                content: content.trim(),                timestamp: parsedTimestamp,                order: messageOrder++,              });            }          }          if (messages.length > 0) {            await prisma.message.createMany({              data: messages as any,            });            console.log(`Added ${messages.length} messages for session ${session.id}`);          }        } catch (error) {          console.error(`Error processing session ${session.id}:`, error);        }      }    }    const unprocessedWithMessages = await prisma.session.count({      where: {        processed: false,        messages: { some: {} }      }    });    if (unprocessedWithMessages > 0) {      console.log(`[Complete Workflow] Processing ${unprocessedWithMessages} sessions`);      await processUnprocessedSessions();    }    return { message: `Complete workflow finished successfully` };  } catch (error) {    console.error('[Complete Workflow] Error:', error);    throw error;  }}