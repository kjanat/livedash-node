// Database schema, one company = one org, linked to users and CSV config
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model Company {
  id                String   @id @default(uuid())
  name              String
  csvUrl            String   // where to fetch CSV
  csvUsername       String?  // for basic auth
  csvPassword       String?
  sentimentAlert    Float?   // e.g. alert threshold for negative chats
  dashboardOpts     String?  // JSON blob for per-company dashboard preferences
  users             User[]
  sessions          Session[]
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String   // hashed, use bcrypt
  company   Company  @relation(fields: [companyId], references: [id])
  companyId String
  role      String   // 'admin' | 'user' | 'auditor'
  resetToken String?
  resetTokenExpiry DateTime?
}

model Session {
  id                  String   @id
  company             Company  @relation(fields: [companyId], references: [id])
  companyId           String
  startTime           DateTime
  endTime             DateTime
  ipAddress           String?
  country             String?
  language            String?
  messagesSent        Int?
  sentiment           Float?   // Original sentiment score (float)
  sentimentCategory   String?  // "positive", "neutral", "negative" from OpenAPI
  escalated           Boolean?
  forwardedHr         Boolean?
  fullTranscriptUrl   String?
  avgResponseTime     Float?
  tokens              Int?
  tokensEur           Float?
  category            String?
  initialMsg          String?
  processed           Boolean? // Flag for post-processing status
  questions           String?  // JSON array of questions asked by user
  summary             String?  // Brief summary of the conversation
  messages            Message[] // Relation to parsed messages
  createdAt           DateTime @default(now())
}

model Message {
  id        String   @id @default(uuid())
  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String
  timestamp DateTime // When the message was sent
  role      String   // "User", "Assistant", "System", etc.
  content   String   // The message content
  order     Int      // Order within the conversation (0, 1, 2, ...)
  createdAt DateTime @default(now())
  
  @@index([sessionId, order]) // Index for efficient ordering queries
}
